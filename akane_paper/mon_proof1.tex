%% write up of monitor algorithm
% Aaron Kane

% at eventually, need to finish writing up safety_monitor()
% should also decide on notation for append, step/bound #, etc

\documentclass[10pt,a4paper]{article}
\usepackage[noend]{algorithmic}
\usepackage{algorithm}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{bussproofs}

\addtolength{\textheight}{1in}
%{\voffset}{-1.5in}

\newcommand{\smon}[1]{\ensuremath{smon(\sigma, \tau, #1)}}
\newcommand{\ty}[1]{\texttt{#1}}
\newcommand{\bptr}{b}
\newcommand{\fptr}{f}
\newcommand{\ov}[1]{\ensuremath{\overline{#1}}}
\newcommand{\ep}{ep}
\newcommand{\cp}{cp}
\newcommand{\rp}[2]{\ensuremath{\langle #1, #2 \rangle}}
\newcommand{\res}[2]{\ensuremath{r_{#1}^{#2}}}
\newcommand{\agmon}{\ensuremath{\mathbf{agmon}}}



\newtheorem{thm}{Theorem}
\newtheorem{tdef}{Definition}
\newtheorem{lemma}{Lemma}

\title{Aggressive Monitor Proof Writeup}
\author{Aaron Kane}

\begin{document}
\maketitle

\section{Definitions}

A residue $\res{\phi}{j} = \rp{j}{\psi}$ is a pair where $j \in \mathbb{N}$ is a position in the log and formula $\psi$.

A formula structure $S_{\phi}^i = \{ r_{\phi}^0, r_{\phi}^1, \ldots r_{\phi}^i \}$ is a list of residues and the history $\mathcal{R}^i = \{ S_{\psi_1}^i, S_{\psi_2}^i,\ldots \}$ is a list of formula structures.



\begin{tdef}[Soundness] For all formula $\varphi$, all $i,j \in \mathbb{N}$ with $j \leq i$, all time stamp sequences $\tau$, all traces $\sigma$, and all formula structures $S^i_{\phi}$ such that 1) $S^i_{\phi} \leftarrow \mathbf{incr}(S^{i-1}_{\phi})$ and 2) $S^{i-1}_{\phi}$ is sound, complete, and prompt, it is the case that: 
%
$\forall \rp{j}{\psi} \in S^i_{\phi}: \quad \sigma, \tau, j \vDash \psi \rightarrow \sigma, \tau, j \vDash \phi$

\end{tdef}

\begin{tdef}[Promptness] For all formula $\varphi$, all $i \in \mathbb{N}$, all time stamp sequences $\tau$, all traces $\sigma$ and all formula structures $S^i_{\phi}$ such that 1) $S^i_{\phi} \leftarrow \mathbf{incr}(S^{i-1}_{\phi})$ and 2) $S^{i-1}_{\phi}$ is sound, complete, and prompt, it is the case that: $\forall j : j \leq i \wedge \tau_i - \tau_j \geq \Delta (\varphi) \rightarrow \exists \rp{j}{\psi} \in S^i_{\phi} \wedge \psi \equiv \top/\bot$

\end{tdef}
\begin{tdef}[Completeness] For all formula $\varphi$, all $i \in \mathbb{N}$, all time stamp sequences $\tau$, all traces $\sigma$ and all formula structures $S^i_{\phi}$ such that $S^i_{\phi}$ is sound, it is the case that: 1) $\sigma, \tau, i \vDash \phi \rightarrow \exists\rp{i}{\psi} \in S^i_{\phi}: \sigma, \tau, i \vDash \psi$ and 2) $\sigma, \tau, i \nvDash \phi \rightarrow \exists\rp{i}{\psi} \in S^i_{\phi}: \sigma, \tau, i \nvDash \psi$

\end{tdef}

With these properties defined, we ultimately wish to prove the correctness of our top-level algorithm \agmon.

\begin{thm}[Correctness of \agmon]
For all formula $\varphi$, all $i \in \mathbb{N}$, all time stamp sequences $\tau$, and all traces $\sigma$ it is the case that $\agmon(\sigma, \tau, \varphi)$
\end{thm}

The correctness of \agmon\ relies on the correctness of $\mathbf{reduce}$, which we show here:
\begin{lemma}[Correctness of $\mathbf{reduce}$]
For all traces $\sigma$, time stamp sequences $\tau$, trace positions $i \in \mathbb{N}$, residues $\rp{j}{\psi}$ where $j \in \mathbb{N}$ and $\psi$ is a wff, and all histories $\mathbb{R}^i$ which are 1) Sound and 2) Complete,
%
it is the case that $\rp{j}{\psi'} \leftarrow \mathbf{reduce}(\sigma,\tau,i,\mathbb{R}^i, \rp{j}{\psi})$ is 1) sound, 2) complete, and 3) prompt
\end{lemma}

\begin{lemma}[Better Correctness of $\mathbf{reduce}$?]
For all traces $\sigma$, 
time stamp sequences $\tau$, 
trace positions $i \in \mathbb{N}$, 
residues $\rp{j}{\psi} \in S^i_{\phi}$ where $j \in \mathbb{N}$ and $\psi$ is a wff, 
and all histories $\mathbb{R}^i$ which are 1) Sound and 2) Complete, (which means $S^i_{\phi}$ is also Sound and Complete)
%
it is the case that $\rp{j}{\psi'} \in S^i_{\phi}$ where $ \rp{j}{\psi'} \leftarrow \mathbf{reduce}(\sigma,\tau,i,\mathbb{R}^i, \rp{j}{\psi})$ is 1) sound, 2) complete, and 3) prompt

\end{lemma}

\pagebreak
\section{Algorithms}
\subsection{Top-level monitoring Algorithm}
Our top level aggressive monitoring algorithm is as follows:


\begin{algorithmic}[1]
\STATE Recognize formulas for which we build structures
\STATE $\mathbb{R}^{-1} \leftarrow \emptyset$; \quad $S^{-1} \leftarrow \emptyset$; \quad $i \leftarrow 0$; \quad $\pi \leftarrow \emptyset$
\LOOP
\FOR{every $\psi \in \text{temp\_sub}(\varphi)$ in increasing size}
	\STATE $S^i_{\psi} \leftarrow S^{i-1}_{\psi} \cup \rp{i}{\psi}$
	\FOR{all $\rp{j}{\psi'} \in S^i_{\psi}$}
		\STATE $\pi' \leftarrow \mathbf{reduce}(\sigma, \tau, i, \pi, \rp{j}{\psi'})$
	\ENDFOR
\ENDFOR
%\STATE Reduce all $\rp{j}{\psi} \in \mathcal{R}^i$
\STATE $\hat{S}_{\varphi}^i \leftarrow S_{\varphi}^{i-1} \cup \rp{i}{\varphi}$
\FOR{all $\rp{j}{\psi} \in \hat{S}_{\varphi}^i$}
	\STATE $\pi \leftarrow \mathbf{reduce}(\sigma, \tau, i, \pi, \rp{j}{\psi})$
\ENDFOR
%\STATE $S^i \leftarrow \mathbf{reduce}(\sigma, \tau, i, R^i, \hat{S}^{i})$
%\STATE Reduce all $\rp{j'}{\psi'} \in S^i$
\STATE \texttt{Report any violations on $S^i$}
\STATE $i \leftarrow i + 1$
\ENDLOOP
\end{algorithmic}


%\subsubsection*{Incrementing formula structure}
%Incrementing the history structure $\mathcal{R}^i$ is done by incrementing all formula structures by the following algorithm:
%\\
%
%\noindent \textbf{Increment formula structure}
%\begin{algorithmic}[1]
%\STATE ${S_{\phi}^{i}} \leftarrow S_{\phi}^{i-1} \cup \rp{i}{\phi}$
%\FOR{all $\res{\phi}{j} \in {S_{\phi}^{i}}$}
%\STATE Reduce $\res{\phi}{j}$
%\ENDFOR
%\end{algorithmic}

%\displaybreak
\subsubsection*{Reduce}
The reduce function takes a residue and returns the reduced residue:

%\begin{align*}

%%% true/false
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\top}) &= \rp{j}{\top} \\
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\bot}) &= \rp{j}{\bot} \\
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{p}) &= \rp{j}{\sigma(p)} \\
\end{align*}
%%% NOT
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\neg \psi}) = \left\{
\begin{aligned}
\text{Let } &\psi' \leftarrow \mathbf{reduce}(\sigma, \tau, i, \pi, \rp{j}{\psi}) \\
&\psi'' \leftarrow \mathbf{simplify}(\neg \psi') \\
&\textbf{return } \rp{j}{\psi''} \\
\end{aligned} \right. \\
\end{align*}

%%% OR
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\alpha \vee \beta} = \left\{
\begin{aligned}
\text{Let } &\alpha' \leftarrow \mathbf{reduce}(\sigma, \tau, i, \pi, \rp{j}{\alpha}) \\
&\beta' \leftarrow \mathbf{reduce}(\sigma, \tau, i, \pi, \rp{j}{\beta}) \\
&\phi' \leftarrow \mathbf{simplify}(\alpha' \vee \beta') \\
&\textbf{return } \rp{j}{\phi'} \\
\end{aligned} \right. \\
\end{align*}

%%% SINCE
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\psi_1 \mathcal{U}_{[l,h]} \psi_2} = \left\{
\begin{aligned}
&test 
\end{aligned} \right. \\
\end{align*}
%%% SINCE
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\psi_1 \mathcal{S}_{[l,h]} \psi_2} = \left\{
\begin{aligned}
&\text{let } a_1 \leftarrow max(\{k | \rp{k}{\psi'} \in S^i_{\psi_1} \wedge \psi' = \bot \}) \\
&a_2 \leftarrow min(\{k | \rp{k}{\psi'} \in S^i_{\psi_1} \wedge \forall j \quad j > k. \exists \rp{j}{\top} \in S^i_{\psi_1} \}) \\
&b_1 \leftarrow max(\{k | \rp{k}{\psi'} \in S^i_{\psi_2} \wedge \psi' \neq \bot/\top \}) \\
&b_2 \leftarrow max(\{k | \rp{k}{\psi'} \in S^i_{\psi_2} \wedge \psi' = \top \}) \\
&\text{if } b_1 < a_1 \\
& \quad\mathbf{return} \rp{j}{\bot} \\
&\text{else if } b_2 > a_2 \\
& \quad\mathbf{return} \rp{j}{\top} \\
&\text{else} \\
& \quad\mathbf{return} \rp{j}{\psi_1 \mathcal{S}_{[l,h]} \psi_2}
\end{aligned} \right. \\
\end{align*}

%%% simplify
\begin{align*}
\mathbf{simplify}(\phi) = \left\{
\begin{aligned}
&\top &\text{ if } \phi \equiv \top \\
&\top &\text{ if } \phi \equiv \neg \bot \\
&\bot &\text{ if } \phi \equiv \bot \\
&\bot &\text{ if } \phi \equiv \neg \top \\
&\top &\text {if } \phi \equiv \psi_1 \vee \psi_2 \\
& &\text{ and } \\ & & \psi_1 \equiv \top \text{ or } \psi_2 \equiv \top \\
&\phi &\text{ otherwise}
\end{aligned} \right. \\
\end{align*}

%\end{align*}

%%\begin{algorithm}
%\noindent \textbf{reduce}
%\begin{algorithmic}[1]
%\IF{$\res{\phi}{j} \equiv \top \vee \res{\phi}{j} \equiv \bot$}
%\RETURN $\res{\phi}{j}$
%%%%%% PROP %%%%%
%\ELSIF{$\res{\phi}{j} \equiv p$}
%\RETURN $\rp{j}{\sigma(p)}$
%%%%%% NOT %%%%%%%%
%\ELSIF{$\res{\phi}{j} \equiv \neg \psi$}
%\STATE $\psi' \leftarrow reduce(\psi)$
%\RETURN $\rp{j}{\neg \psi'}$
%%%%%% OR %%%%%%%%%%
%\ELSIF{$\res{\phi}{j} \equiv \psi_1 \vee \psi_2$}
%\STATE $\psi_1' \leftarrow reduce(\psi_1)$
%\STATE $\psi_2' \leftarrow reduce(\psi_2)$
%\RETURN $\rp{j}{\psi_1' \vee \psi_2'}$
%%%%%% UNTIL %%%%%%%%%%%%%%%
%\ELSIF{$\res{\phi}{j} \equiv \psi_1 \mathcal{U}_{[l,h]} \psi_2$}
%\STATE $e \leftarrow \text{smallest } k \in [j+l,j+h] \text{ s.t. } \res{\psi_2}{k} = \top$
%\IF{$e \equiv \emptyset$}
%\STATE $v \leftarrow \text{largest } k \in S_{\psi_2}^i \text{ s.t. } \res{\psi_2}{k} = \top/\bot$
%\IF{$v \geq j+h$}
%\RETURN $\rp{j}{\bot}$
%\ELSE
%\RETURN $\res{\phi}{j}$
%\ENDIF
%\ENDIF % if no e
%\STATE unfinished $\leftarrow \bot$
%\FOR{all $ k \in S_{\psi_2} \text{ s.t. } k \in [j, e]$}
%\IF{$\res{\psi_2}{k} \equiv \bot$}
%\RETURN $\rp{j}{\bot}$
%\ELSIF{$\res{\psi_2}{k} \not\equiv \top$}
%\STATE unfinished $\leftarrow \top$
%\ENDIF % checking psi_1
%\ENDFOR
%\IF{unfinished $\equiv \top$}
%\RETURN $\res{\phi}{j}$
%\ELSE
%\RETURN $\rp{j}{\top}$
%\ENDIF
%%%%%%%% SINCE
%\ELSIF{$\res{\phi}{j} \equiv \psi_1 \mathcal{S}_{[l,h]} \psi_2$}
%\STATE $s \leftarrow \text{largest } k \in [j+l,j+h] \text{ s.t. } \res{\psi_2}{k} = \top$
%\IF{$s \equiv \emptyset$}
%\STATE $v \leftarrow \text{largest } k \in S_{\psi_2}^i \text{ s.t. } \res{\psi_2}{k} = \top/\bot$
%\IF{$v \geq j+h$}
%\RETURN $\rp{j}{\bot}$
%\ELSE
%\RETURN $\res{\phi}{j}$
%\ENDIF
%\ENDIF % if no s
%\STATE unfinished $\leftarrow \bot$
%\FOR{all $k \in S_{\psi_2}: k \in [s, j]$}
%\IF{$\res{\psi_2}{k} \equiv \bot$}
%\RETURN $\rp{j}{\bot}$
%\ELSIF{$\res{\psi_2}{k} \not\equiv \top$}
%\STATE unfinished $\leftarrow \top$
%\ENDIF % checking psi_1
%\ENDFOR
%\IF{unfinished $= \top$}
%\RETURN $\res{\phi}{j}$
%\ELSE
%\RETURN $\rp{j}{\top}$
%\ENDIF
%\ENDIF % outer if
%\end{algorithmic}
%%\end{algorithm}

\section{Soundness/Completeness Proofs}

The soundness and completeness of our top-level algorithm ultimately depends on the soundness and completeness of the reduce algorithm. So first, we show that reduce is sound and complete.

\begin{thm}
The function $\hat{r}^{\phi}_{j} \leftarrow reduce(\sigma_i, \tau_i, \mathbb{R}^i, \res{j}{\phi})$ is sound, complete, and prompt when $\mathbb{R}^i, \res{j}{\phi}$ are sound, complete, and prompt.
\end{thm}
\noindent We will show that the properties hold over the form of $\phi$: \\
\\ \noindent \textbf{Case} $\phi \equiv \top/\bot$: \\
reduce is trivially sound, complete and prompt since we do not change the residue.

\noindent \textbf{Case} $\phi \equiv p$ \\
reduce is trivially sound, from the semantics we know $\sigma, \tau, j \vDash p \leftrightarrow \sigma, \tau, j \vDash \sigma_j(p)$. Promptness is trivial since reduce will always return the reduced truth value of a proposition.  For completeness we know that $\sigma, \tau, j \vDash p \rightarrow \sigma, \tau, j \vDash \sigma_j(p)$ and $\sigma, \tau, j \nvDash p \rightarrow \sigma, \tau, j \nvDash \sigma_j (p)$, so replacing $p$ with $\sigma_j(p)$ is complete.
\\ \\ 
\noindent \textbf{Case} $\phi \equiv \neg \psi$ \\
reduce is trivially sound...
\\ \\
\noindent \textbf{Case} $\phi \equiv \psi_1 \vee \psi_2$ \\
...
\\ \\
\noindent \textbf{Case} $\phi \equiv \psi_1 \mathcal{U}_{[l,h]} \psi_2$: \\
Soundness is simple in this case, since reduce either returns $\res{j}{\phi}$ which is trivially sound, or it returns the semantically correct truth value ($\top/\bot$). Reduce will only return $\top$ if $\exists k \in [j+l,j+h]$ s.t. $\res{k}{\psi_2} = \top$ and $\forall k' \in [j,e]$ $\res{k'}{\psi_1} = \top$ (if any $\psi_1$ residue is $\bot$ then $\bot$ will be returned, and if any are not yet evaluated then unfinished is set and the original residue is returned). This is the semantics of $\mathcal{U}$, so we know that a returned $\top/\bot \rightarrow \sigma, \tau, j \vDash \phi$. Thus reduce is sound for $\mathcal{U}$.

Completeness is trivial because the only possible reduction is a sound $\top/\bot$ value or the original $\phi$. So for all $\res{j}{\psi} \in S^i_{\psi_1 \mathcal{U}_{[l,h]} \psi_2}$ we have $\res{\psi}{j} \equiv \rp{j}{\psi_1 \mathcal{U}_{[l,h]} \psi_2}$ or $\res{\psi}{j} \equiv \top/\bot$. Since reduce is sound, if the residue is $\top/\bot$ we know that the residue value is correct ($\top$ if $\sigma, \tau, j \vDash \phi$ and $\bot$ otherwise) and if a residue $\res{\phi}{j} \equiv \rp{j}{\phi}$ it is trivially complete.

Reduce is prompt $\mathbf{reduce}$


\section{Description}
Our runtime monitoring algorithm \agmon takes as input a well-formed bmtl formula $\varphi$, monitors the system trace as it grows, builds history structures for temporal subformula of $\varphi$ and reports violations of $\varphi$ as soon as they are detected.

We summarize the relevant functions below: \\
$\agmon(\varphi)$ is our top-level monitor function. \\
$\mathbf{incr}(\sigma_i, \tau, i, \hat{\mathcal{R}}^i, \psi)$ updates the history structure $S^i_{\psi}$ based on the new trace entry $\sigma_i$ \\ 
$\mathbf{reduce}(\sigma_i,\tau, i, \mathcal{R}^i, \res{\psi}{j})$ takes a residue $\res{\psi}{j}$ and returns a reduced residue based on the history $\mathcal{R}^i$ and current state $\sigma_i, \tau_i$. 
\end{document}
