%% write up of monitor algorithm
% Aaron Kane

% at eventually, need to finish writing up safety_monitor()
% should also decide on notation for append, step/bound #, etc

\documentclass[10pt,a4paper]{article}
\usepackage[noend]{algorithmic}
\usepackage{algorithm}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{bussproofs}

%\addtolength{\textheight}{1in}
%{\voffset}{-1.5in}

\newcommand{\smon}[1]{\ensuremath{smon(\sigma, \tau, #1)}}
\newcommand{\ty}[1]{\texttt{#1}}
\newcommand{\bptr}{b}
\newcommand{\fptr}{f}
\newcommand{\ov}[1]{\ensuremath{\overline{#1}}}
\newcommand{\ep}{ep}
\newcommand{\cp}{cp}
\newcommand{\rp}[2]{\ensuremath{\langle #1, #2 \rangle}}
\newcommand{\res}[2]{\ensuremath{r_{#1}^{#2}}}
\newcommand{\agmon}{\ensuremath{\mathbf{agmon}}}



\newtheorem{thm}{Theorem}
\newtheorem{tdef}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{case}{Case}

\title{Aggressive Monitor Proof Writeup}
\author{Aaron Kane}

\begin{document}
\maketitle

\section{Definitions}

A residue $\res{\phi}{j} = \rp{j}{\psi}$ is a pair where $j \in \mathbb{N}$ is a position in the log and formula $\psi$.

A formula structure $S_{\phi}^i = \{ r_{\phi}^0, r_{\phi}^1, \ldots r_{\phi}^i \}$ is a list of residues and the history $\mathcal{R}^i = \{ S_{\psi_1}^i, S_{\psi_2}^i,\ldots \}$ is a list of formula structures.



%\begin{tdef}[Soundness] For all formula $\varphi$, all $i,j \in \mathbb{N}$ with $j \leq i$, all time stamp sequences $\tau$, all traces $\sigma$, and all formula structures $S^i_{\phi}$ such that 1) $S^i_{\phi} \leftarrow \mathbf{incr}(S^{i-1}_{\phi})$ and 2) $S^{i-1}_{\phi}$ is sound, complete, and prompt, it is the case that: 
%
%$\forall \rp{j}{\psi} \in S^i_{\phi}: \quad \sigma, \tau, j \vDash \psi \rightarrow \sigma, \tau, j \vDash \phi$
%\end{tdef}
\begin{tdef}[Soundness] For all formula $\phi$, all $i,j \in \mathbb{N}$ with $j \leq i$, all time step sequences $\tau$, and all traces $\sigma$, we say a formula structure $S^i_{\phi}$ is sound iff:
$\forall \rp{j}{\psi} \in S^i_{\phi}: \quad \sigma, \tau, j \vDash \psi \rightarrow \sigma, \tau, j \vDash \phi$
\end{tdef}

%\begin{tdef}[Promptness] For all formula $\varphi$, all $i \in \mathbb{N}$, all time stamp sequences $\tau$, all traces $\sigma$ and all formula structures $S^i_{\phi}$ such that 1) $S^i_{\phi} \leftarrow \mathbf{incr}(S^{i-1}_{\phi})$ and 2) $S^{i-1}_{\phi}$ is sound, complete, and prompt, it is the case that: $\forall j : j \leq i \wedge \tau_i - \tau_j \geq \Delta (\varphi) \rightarrow \exists \rp{j}{\psi} \in S^i_{\phi} \wedge \psi \equiv \top/\bot$
%\end{tdef}

\begin{tdef}[Promptness]
For all formula $\phi$, all $i \in \mathbb{N}$, all traces $\sigma$, and all time sequences $\tau$, a formula structure $S^i_{\phi}$ is prompt iff: 
$\forall \rp{j}{\psi} \in S^i_{\phi}.( \tau_i - \tau_j \geq \Delta(\phi) \rightarrow \psi \equiv \top/\bot)$
\end{tdef}

\begin{tdef}[$\phi$-Promptness]
A history $R^i$ is $\phi$-prompt if for all $i \in \mathbb{N}$, all traces $\sigma$, and all time sequences $\tau$: for all temporal subformula and their subformula $\psi$ of $\phi$: $S^i_{\psi}$ is prompt.
\end{tdef}

\begin{tdef}[Completeness] For all formula $\varphi$, all $i \in \mathbb{N}$, all time stamp sequences $\tau$, all traces $\sigma$ and all formula structures $S^i_{\phi}$ such that $S^i_{\phi}$ is sound, then we say the structure $S^i_{\phi}$ is complete if it is the case that: 
$\forall j \leq i$:
1) $\sigma, \tau, j \vDash \phi \rightarrow \exists\rp{j}{\psi} \in S^i_{\phi}: \sigma, \tau, j \vDash \psi$ 
and 
2) $\sigma, \tau, j \nvDash \phi \rightarrow \exists\rp{j}{\psi} \in S^i_{\phi}: \sigma, \tau, j \nvDash \psi$

\end{tdef}

With these properties defined, we ultimately wish to prove the correctness of our top-level algorithm \agmon.

\begin{thm}[Correctness of \agmon]
For all formula $\varphi$, all $i \in \mathbb{N}$, all time stamp sequences $\tau$, and all traces $\sigma$ it is the case that if $S^i_{\varphi}$ is 1) sound, 2) complete, and 3) prompt then $\exists j.(\rp{j}{\bot} \in S^i_{\varphi}) \leftrightarrow \sigma, \tau, j \nvDash \varphi$
\end{thm}

\subsection{Proof of \agmon\ Correctness}
In this section we present some assisting lemmas and definitions we will use to show the correctness of \agmon.


First, we have the fact that adding the current timestep's residue to a sound and complete formula structure leaves that structure sound and complete:

\begin{lemma}[Soundness and Completeness of structure extension]
For all well formed formula $\phi$, all $i \in \mathbb{N}$ and all formula structures $S^{i-1}_{\phi}$ such that $S^{i-1}_{\phi}$ is sound and complete then the extension $\hat{S}^{i}_{\phi} \leftarrow S^{i-1}_{\phi} \cup \rp{i}{\phi}$ is 1) Sound and 2) Complete.
\end{lemma}

\noindent \emph{Proof}. If $S^{i-1}_{\phi}$ is sound then $S^{i-1}_{\phi} \cup \rp{i}{\phi}$ is sound since $\sigma, \tau, i \vDash \phi \rightarrow \sigma, \tau, i \vDash \phi$. Similarly, if $S^{i-1}_{\phi}$ is complete than $S^{i-1}_{\phi} \cup \rp{i}{\phi}$ is complete since we know that there exists the residue $\rp{i}{\phi} \in {S}^{i}_{\phi}$ and since $\phi$ is a well formed formula, either $\sigma, \tau, i \vDash \phi \rightarrow \sigma, \tau, i \vDash \phi$ or $\sigma, \tau, i \nvDash \phi \rightarrow \sigma, \tau, i \nvDash \phi$

\begin{lemma}[Correctness of $\mathbf{simplify}$]
if $\phi$ is a well formed formula and $\phi' \leftarrow \mathbf{simplify}(\phi)$ then it is the case that $\phi \leftrightarrow \phi'$
\end{lemma}

\noindent \emph{Proof}. Trivial by the semantics of our logic. \\

\begin{tdef}[Residue Soundness]
We say a residue $\rp{j}{\psi}$ is sound with respect to a formula $\phi$ if for all traces $\sigma$ and time sequences $\tau$: $\sigma, \tau, j \vDash \psi \rightarrow \sigma, \tau, j \vDash \phi$. \\

\noindent A residue $\rp{j}{\psi}$ is sound with respect to a formula structure $S^i_{\phi}$ if it is sound with respect to $\phi$.
\end{tdef}

\begin{lemma}[Sound-residue filled structures are sound]
A formula structure $S^i_{\phi}$ is sound if all residues $\rp{j}{\psi}$ contained within it are sound with respect to $\phi$:
%$\forall \rp{j}{\psi} \in S^i_{\phi}$, $\rp{j}{\psi}$ is sound with respect to $\phi$.
\end{lemma}

\noindent \emph{Proof}. Follows directly from the definition of soundness and residue soundness. \\


\begin{tdef}[Residue Completeness]
We say a residue $\rp{j}{\psi}$ is complete with respect to a formula $\phi$ if for all traces $\sigma$ and time sequences $\tau$: $\sigma,\tau, j \vDash \phi \rightarrow \sigma,\tau,j \vDash \psi$ and $\sigma,\tau,j \nvDash \phi \rightarrow \sigma, \tau, j \nvDash \psi$.
\end{tdef}

\begin{lemma}[Complete-residue filled structures are complete]
A formula structure $S^i_{\phi}$ is complete if all residues $\rp{j}{\psi}$ contained within it are complete with respect to $\phi$ and $\forall j \leq i.(\rp{j}{\psi} \in S^i_{\psi})$.
\end{lemma}

\noindent \emph{Proof}. Follows directly from the definition of completeness and residue completeness. We require that a residue exist for all $j \leq i$ and that they all fulfill the completeness restriction. \\

Next we show the correctness of the $\mathbf{reduce}$ function, which is our primary function that checks whether an individual residue is satisfied, violated, or can be reduced to a simpler formula.

\subsubsection{Correctness of reduce}
\begin{lemma}[Correctness of $\mathbf{reduce}$]
For all traces $\sigma$, time stamp sequences $\tau$, trace positions $i \in \mathbb{N}$, residues $\rp{j}{\psi}$ where $j \in \mathbb{N}$ and $\psi$ is a wff, and all histories $\mathbb{R}^i$ which are 1) Sound and 2) Complete,
%
it is the case that $\rp{j}{\psi'} \leftarrow \mathbf{reduce}(\sigma,\tau,i,\mathbb{R}^i, \rp{j}{\psi})$ is 1) sound, 2) complete, and 3) prompt
\end{lemma}

\begin{lemma}[Better Correctness of $\mathbf{reduce}$?]
For all traces $\sigma$, 
time stamp sequences $\tau$, 
trace positions $i \in \mathbb{N}$, 
residues $\rp{j}{\psi} \in S^i_{\phi}$ where $j \in \mathbb{N}$ and $\psi$ is a wff, 
and all histories $\mathbb{R}^i$ which are 1) Sound and 2) Complete, (which means $S^i_{\phi}$ is also Sound and Complete)
%
it is the case that $\rp{j}{\psi'} \in S^i_{\phi}$ where $ \rp{j}{\psi'} \leftarrow \mathbf{reduce}(\sigma,\tau,i,\mathbb{R}^i, \rp{j}{\psi})$ is 1) sound, 2) complete, and 3) prompt
\end{lemma}

\begin{lemma}[Residue Correctness of $\mathbf{reduce}$]
For all formula $\phi$,
all traces $\sigma$, 
all time stamp sequences $\tau$, 
all trace positions $i \in \mathbb{N}$, 
all residues $\rp{j}{\psi} \in S^i_{\phi}$ where $j \in \mathbb{N}$ and $\psi,\phi$ are wff, 
and all histories $\mathbb{R}^i$ which are 1) Sound and 2) Complete, and 3) $\phi$-Prompt 
%
it is the case that $\rp{j}{\psi'} \leftarrow \mathbf{reduce}(\sigma,\tau,i,\mathbb{R}^i, \rp{j}{\psi})$ is 1) sound, 2) complete, and 3) prompt with respect to $\phi$.
\end{lemma}


\noindent \emph{Proof}. By induction over the formula structure $\phi$.

We will show all three properties separately, for each formula case, starting with soundness:

\begin{proof}[Soundness]

% TRUE
\noindent \textbf{Case} $\phi \equiv \top$ \\
In this case reduce is trivially sound, 

% TRUE
\noindent \textbf{Case} $\phi \equiv \bot$ \\
In this case reduce is trivially sound, 

% PROP
\noindent \textbf{Case} $\phi \equiv p$ \\
In this case reduce is trivially sound, 

% NOT
\noindent \textbf{Case} $\phi \equiv \neg \psi$ \\
Given that $\mathbf{reduce}(\psi)$ is sound and $\mathbf{simplify}$ is sound (lemma 2), then $\mathbf{reduce}$ is sound for $\neg \psi$.

% OR
\noindent \textbf{Case} $\phi \equiv \psi_1 \vee \psi_2$ \\
Given that $\mathbf{reduce}(\psi_1)$ and $\mathbf{reduce}(\psi_2)$ are both sound and $\mathbf{simplify}$ is sound (lemma 2), then $\mathbf{reduce}(\psi_1 \vee \psi_2)$ is sound.

% UNTIL
\noindent \textbf{Case} $\phi \equiv \psi_1 \mathcal{U}_{[l,h]} \psi_2$ \\
There are three cases for Until: \\
\textbf{Subcase} $b_2 \neq \emptyset \wedge a_2 \neq \emptyset \wedge b_2 \leq a_2$ \\
This is the True case for Until. If $b_2$ is non-empty then there exists a residue $\rp{j}{\top} \in S^i_{\phi_2}$ and since $S^i_{\phi_2}$ is sound we know that $\sigma, \tau, j \vDash \phi_2$ with $j \in [i+l,i+h]$. If $a_2$ is non-empty then we know that all residues in $[i,a_2]$ are true, and thus $\forall j \in [i,a_2]: \sigma, \tau, j \vDash \psi_1$. If $b_2 \leq a_2$ then there exists a $k$ such that $\sigma, \tau, k \vDash \psi_2$ ($b_2$) and for all $k' \in [i,k] \sigma, \tau, k' \vDash \psi_1$ (since $a_2 > k$). This is the semantics of Until, so we know that $\sigma, \tau, j \vDash \psi_1 \mathcal{U}_{[l,h]} \psi_2$. \\
\textbf{Subcase} $(b_1 \neq \emptyset \vee b_2 \neq \emptyset) \wedge a_1 \neq \emptyset \wedge min(b_1,b_2) \geq a_1$ or $b_f = \top$ \\
This is the False case for Until. If $b_1$ or $b_2$ is non-empty then the minimum of those two is the earliest position in $[i+l,i+h]$ where $\psi_2$ could be True. If $a_1$ is non-empty then there is a position in $\psi_1$ where $\tau, \sigma, a_1 \nvDash \psi_1$. 
If $a_1 \leq min(b_1,b_2)$ then it is impossible for $\psi_1 \mathcal{U}_{[l,h]} \psi_2$ to be True since $\psi_1$ is not True from position $i$ to the earliest point that $\psi_2$ could be True. \\
Otherwise if $b_f = \top$ then for all positions in $[i+l,i+h]$ we know that $\psi_2$ is False, so $\psi_1 \mathcal{U}_{[l,h]} \psi_2$ must be False. \\
\textbf{Subcase} Otherwise \\
returning $\phi$ is trivially sound since $\sigma, \tau, j \vDash \phi \rightarrow \sigma, \tau, j \vDash \phi$.


% SINCE
\noindent \textbf{Case} $\phi \equiv \psi_1 \mathcal{S}_{[l,h]} \psi_2$ \\
The proof for since is similar to the proof for Until
\end{proof}


\begin{proof}[Promptness]

% TRUE
\noindent \textbf{Case} $\phi \equiv \top$ \\
This case is trivially Prompt

% FALSE 
\noindent \textbf{Case} $\phi \equiv \bot$ \\
This case is trivially Prompt

% PROP
\noindent \textbf{Case} $\phi \equiv p$ \\
This case is trivially Prompt

% NOT
\noindent \textbf{Case} $\phi \equiv \neg \psi$ \\
Given that $\mathbf{reduce}(\psi)$ and $\mathbf{simplify}$ are Prompt then $\mathbf{reduce}(\neg \psi)$ is Prompt

% OR
\noindent \textbf{Case} $\phi \equiv \psi_1 \vee \psi_2$ \\
Given that $\mathbf{reduce}(\psi_1)$, $\mathbf{reduce}(\psi_2)$ and $\mathbf{simplify}$ are Prompt then $\mathbf{reduce}(\psi_1 \vee \psi_2)$ is Prompt

% UNTIL
\noindent \textbf{Case} $\phi \equiv \psi_1 \mathcal{U}_{[l,h]} \psi_2$ \\
First, we note that because $S^i_{\psi_1}$ and $S^i_{\psi_2}$ are Prompt, they contain no unfinished residues. This means that either $a_1$ or $a_2$ must be non-empty 
There are three cases for Until: \\
\textbf{Subcase} $b_2 \neq \emptyset \wedge a_2 \neq \emptyset \wedge b_2 \leq a_2$ \\
\textbf{Subcase} $(b_1 \neq \emptyset \vee b_2 \neq \emptyset) \wedge a_1 \neq \emptyset \wedge min(b_1,b_2) \geq a_1$ \\
\textbf{Subcase} Otherwise \\
\end{proof}

\pagebreak
\section{Algorithms}
\subsection{Top-level monitoring Algorithm}
Our top level aggressive monitoring algorithm is as follows:


\begin{algorithmic}[1]
\STATE Recognize formulas for which we build structures
\STATE $\mathbb{R}^{-1} \leftarrow \emptyset$; \quad $S^{-1} \leftarrow \emptyset$; \quad $i \leftarrow 0$; \quad $\pi \leftarrow \emptyset$
\LOOP
\STATE $\mathbb{R}^i \leftarrow \mathbb{R}^{i-1}$
\FOR{every $\psi \in \text{temp\_sub}(\varphi)$ in increasing size}
	\STATE $S^i_{\psi} \leftarrow S^{i-1}_{\psi} \cup \rp{i}{\psi}$
	\FOR{all $\rp{j}{\psi'} \in S^i_{\psi}$}
		\STATE $S^i_{\psi} \leftarrow \mathbf{reduce}(\sigma, \tau, i, \mathbb{R}^i, \rp{j}{\psi'})$
	\ENDFOR
\ENDFOR
%\STATE Reduce all $\rp{j}{\psi} \in \mathcal{R}^i$
\STATE ${S}_{\varphi}^i \leftarrow S_{\varphi}^{i-1} \cup \rp{i}{\varphi}$
\FOR{all $\rp{j}{\psi} \in {S}_{\varphi}^i$}
	\STATE $S^i_{\varphi} \leftarrow \mathbf{reduce}(\sigma, \tau, i, \mathbb{R}^i, \rp{j}{\psi})$
\ENDFOR
%\STATE $S^i \leftarrow \mathbf{reduce}(\sigma, \tau, i, R^i, \hat{S}^{i})$
%\STATE Reduce all $\rp{j'}{\psi'} \in S^i$
\FOR{all $\rp{j}{\bot} \in S^i_{\varphi}$}
\STATE \texttt{Report violation on $\sigma$ at position $j$}
\ENDFOR
\STATE $i \leftarrow i + 1$
\ENDLOOP
\end{algorithmic}


%\subsubsection*{Incrementing formula structure}
%Incrementing the history structure $\mathcal{R}^i$ is done by incrementing all formula structures by the following algorithm:
%\\
%
%\noindent \textbf{Increment formula structure}
%\begin{algorithmic}[1]
%\STATE ${S_{\phi}^{i}} \leftarrow S_{\phi}^{i-1} \cup \rp{i}{\phi}$
%\FOR{all $\res{\phi}{j} \in {S_{\phi}^{i}}$}
%\STATE Reduce $\res{\phi}{j}$
%\ENDFOR
%\end{algorithmic}

%\displaybreak
\subsubsection*{Reduce}
The reduce function takes a residue and returns the reduced residue:

%\begin{align*}

%%% true/false
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\top}) &= \rp{j}{\top} \\
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\bot}) &= \rp{j}{\bot} \\
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{p}) &= \rp{j}{\sigma(p)} \\
\end{align*}
%%% NOT
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\neg \psi}) = \left\{
\begin{aligned}
\text{Let } &\psi' \leftarrow \mathbf{reduce}(\sigma, \tau, i, \pi, \rp{j}{\psi}) \\
&\psi'' \leftarrow \mathbf{simplify}(\neg \psi') \\
&\textbf{return } \rp{j}{\psi''} \\
\end{aligned} \right. \\
\end{align*}

%%% OR
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\alpha \vee \beta} = \left\{
\begin{aligned}
\text{Let } &\alpha' \leftarrow \mathbf{reduce}(\sigma, \tau, i, \pi, \rp{j}{\alpha}) \\
&\beta' \leftarrow \mathbf{reduce}(\sigma, \tau, i, \pi, \rp{j}{\beta}) \\
&\phi' \leftarrow \mathbf{simplify}(\alpha' \vee \beta') \\
&\textbf{return } \rp{j}{\phi'} \\
\end{aligned} \right. \\
\end{align*}

%%% UNTIL
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\psi_1 \mathcal{U}_{[l,h]} \psi_2}) = \left\{
\begin{aligned}
&\text{let } a_1 \leftarrow min(\{k | k \in [i+l, i+h] \wedge \rp{k}{\psi'} \in S^i_{\psi_1} \wedge \psi' = \bot \}) \\
&a_2 \leftarrow max(\{k | k \in [i+l, i+h] \wedge  \rp{k}{\psi'} \in S^i_{\psi_1} \\  
	& \quad \quad \quad \quad \wedge \forall j. (i \leq j \leq k \rightarrow \rp{j}{\top} \in S^i_{\psi_1}) \}) \\
&b_1 \leftarrow min(\{k | k \in [i+l, i+h] \wedge \rp{k}{\psi'} \in S^i_{\psi_2} \wedge \psi' \neq \bot/\top \}) \\
&b_2 \leftarrow min(\{k | k \in [i+l, i+h] \wedge \rp{k}{\psi'} \in S^i_{\psi_2} \wedge \psi' = \top \}) \\
&b_f \leftarrow \top \text{ if } \forall k \in [i+l,i+h]. \rp{k}{\bot} \in S^i_{\psi_2} \\
&\text{if }b_2 \neq \emptyset \wedge a_2 \neq \emptyset \wedge b_2 \leq a_2 \\
& \quad\mathbf{return} \rp{j}{\top} \\
&\text{else if } (b_1 \neq \emptyset \vee b_2 \neq \emptyset) \wedge a_1 \neq \emptyset \wedge min(b_1,b_2) \geq a_1 \text{ or } b_f = \top\\
& \quad\mathbf{return} \rp{j}{\bot} \\
&\text{else} \\
& \quad\mathbf{return} \rp{j}{\psi_1 \mathcal{S}_{[l,h]} \psi_2}
\end{aligned} \right. \\
\end{align*}
%%% SINCE
\begin{align*}
\mathbf{reduce}(\sigma,\tau, i,\pi,\rp{j}{\psi_1 \mathcal{S}_{[l,h]} \psi_2} = \left\{
\begin{aligned}
&\text{let } a_1 \leftarrow max(\{k | k \in [i-h, i-l] \wedge \rp{k}{\psi'} \in S^i_{\psi_1} \wedge \psi' = \bot \}) \\
&a_2 \leftarrow min(\{k | k \in [i-h, i-l] \wedge \rp{k}{\psi'} \in S^i_{\psi_1} \\
&\quad \quad \quad \quad \wedge \forall j. (j \geq k \rightarrow \rp{j}{\top} \in S^i_{\psi_1}) \}) \\
&b_1 \leftarrow max(\{k | k \in [i-h, i-l] \wedge \rp{k}{\psi'} \in S^i_{\psi_2} \wedge \psi' \neq \bot/\top \}) \\
&b_2 \leftarrow max(\{k | k \in [i-h, i-l] \wedge \rp{k}{\psi'} \in S^i_{\psi_2} \wedge \psi' = \top \}) \\
&b_f \leftarrow \top \text{ if } \forall k \in [i+l,i+h]. \rp{k}{\bot} \in S^i_{\psi_2} \\
&\text{if } b_2 \neq \emptyset \wedge a_2 \neq \emptyset \wedge b_2 \geq a_2 \\
& \quad\mathbf{return} \rp{j}{\top} \\
&\text{else if } (b_1 \neq \emptyset \vee b_2 \neq \emptyset) \wedge a_1 \neq \emptyset \wedge max(b_1,b_2) \leq a_1 \text{ or } b_f = \top\\
& \quad\mathbf{return} \rp{j}{\bot} \\
&\text{else} \\
& \quad\mathbf{return} \rp{j}{\psi_1 \mathcal{S}_{[l,h]} \psi_2}
\end{aligned} \right. \\
\end{align*}

%%% simplify
\begin{align*}
\mathbf{simplify}(\phi) = \left\{
\begin{aligned}
&\top &\text{ if } \phi \equiv \top \\
&\top &\text{ if } \phi \equiv \neg \bot \\
&\bot &\text{ if } \phi \equiv \bot \\
&\bot &\text{ if } \phi \equiv \neg \top \\
&\top &\text {if } \phi \equiv \psi_1 \vee \psi_2 \\
& &\text{ and } \\ & & \psi_1 \equiv \top \text{ or } \psi_2 \equiv \top \\
&\phi &\text{ otherwise}
\end{aligned} \right. \\
\end{align*}

%\end{align*}

%%\begin{algorithm}
%\noindent \textbf{reduce}
%\begin{algorithmic}[1]
%\IF{$\res{\phi}{j} \equiv \top \vee \res{\phi}{j} \equiv \bot$}
%\RETURN $\res{\phi}{j}$
%%%%%% PROP %%%%%
%\ELSIF{$\res{\phi}{j} \equiv p$}
%\RETURN $\rp{j}{\sigma(p)}$
%%%%%% NOT %%%%%%%%
%\ELSIF{$\res{\phi}{j} \equiv \neg \psi$}
%\STATE $\psi' \leftarrow reduce(\psi)$
%\RETURN $\rp{j}{\neg \psi'}$
%%%%%% OR %%%%%%%%%%
%\ELSIF{$\res{\phi}{j} \equiv \psi_1 \vee \psi_2$}
%\STATE $\psi_1' \leftarrow reduce(\psi_1)$
%\STATE $\psi_2' \leftarrow reduce(\psi_2)$
%\RETURN $\rp{j}{\psi_1' \vee \psi_2'}$
%%%%%% UNTIL %%%%%%%%%%%%%%%
%\ELSIF{$\res{\phi}{j} \equiv \psi_1 \mathcal{U}_{[l,h]} \psi_2$}
%\STATE $e \leftarrow \text{smallest } k \in [j+l,j+h] \text{ s.t. } \res{\psi_2}{k} = \top$
%\IF{$e \equiv \emptyset$}
%\STATE $v \leftarrow \text{largest } k \in S_{\psi_2}^i \text{ s.t. } \res{\psi_2}{k} = \top/\bot$
%\IF{$v \geq j+h$}
%\RETURN $\rp{j}{\bot}$
%\ELSE
%\RETURN $\res{\phi}{j}$
%\ENDIF
%\ENDIF % if no e
%\STATE unfinished $\leftarrow \bot$
%\FOR{all $ k \in S_{\psi_2} \text{ s.t. } k \in [j, e]$}
%\IF{$\res{\psi_2}{k} \equiv \bot$}
%\RETURN $\rp{j}{\bot}$
%\ELSIF{$\res{\psi_2}{k} \not\equiv \top$}
%\STATE unfinished $\leftarrow \top$
%\ENDIF % checking psi_1
%\ENDFOR
%\IF{unfinished $\equiv \top$}
%\RETURN $\res{\phi}{j}$
%\ELSE
%\RETURN $\rp{j}{\top}$
%\ENDIF
%%%%%%%% SINCE
%\ELSIF{$\res{\phi}{j} \equiv \psi_1 \mathcal{S}_{[l,h]} \psi_2$}
%\STATE $s \leftarrow \text{largest } k \in [j+l,j+h] \text{ s.t. } \res{\psi_2}{k} = \top$
%\IF{$s \equiv \emptyset$}
%\STATE $v \leftarrow \text{largest } k \in S_{\psi_2}^i \text{ s.t. } \res{\psi_2}{k} = \top/\bot$
%\IF{$v \geq j+h$}
%\RETURN $\rp{j}{\bot}$
%\ELSE
%\RETURN $\res{\phi}{j}$
%\ENDIF
%\ENDIF % if no s
%\STATE unfinished $\leftarrow \bot$
%\FOR{all $k \in S_{\psi_2}: k \in [s, j]$}
%\IF{$\res{\psi_2}{k} \equiv \bot$}
%\RETURN $\rp{j}{\bot}$
%\ELSIF{$\res{\psi_2}{k} \not\equiv \top$}
%\STATE unfinished $\leftarrow \top$
%\ENDIF % checking psi_1
%\ENDFOR
%\IF{unfinished $= \top$}
%\RETURN $\res{\phi}{j}$
%\ELSE
%\RETURN $\rp{j}{\top}$
%\ENDIF
%\ENDIF % outer if
%\end{algorithmic}
%%\end{algorithm}

\end{document}



%%%% old stuff, don't really need but keeping around for now...
\section{Soundness/Completeness Proofs}

The soundness and completeness of our top-level algorithm ultimately depends on the soundness and completeness of the reduce algorithm. So first, we show that reduce is sound and complete.

\begin{thm}
The function $\hat{r}^{\phi}_{j} \leftarrow reduce(\sigma_i, \tau_i, \mathbb{R}^i, \res{j}{\phi})$ is sound, complete, and prompt when $\mathbb{R}^i, \res{j}{\phi}$ are sound, complete, and prompt.
\end{thm}
\noindent We will show that the properties hold over the form of $\phi$: \\
\\ \noindent \textbf{Case} $\phi \equiv \top/\bot$: \\
reduce is trivially sound, complete and prompt since we do not change the residue.

\noindent \textbf{Case} $\phi \equiv p$ \\
reduce is trivially sound, from the semantics we know $\sigma, \tau, j \vDash p \leftrightarrow \sigma, \tau, j \vDash \sigma_j(p)$. Promptness is trivial since reduce will always return the reduced truth value of a proposition.  For completeness we know that $\sigma, \tau, j \vDash p \rightarrow \sigma, \tau, j \vDash \sigma_j(p)$ and $\sigma, \tau, j \nvDash p \rightarrow \sigma, \tau, j \nvDash \sigma_j (p)$, so replacing $p$ with $\sigma_j(p)$ is complete.
\\ \\ 
\noindent \textbf{Case} $\phi \equiv \neg \psi$ \\
reduce is trivially sound...
\\ \\
\noindent \textbf{Case} $\phi \equiv \psi_1 \vee \psi_2$ \\
...
\\ \\
\noindent \textbf{Case} $\phi \equiv \psi_1 \mathcal{U}_{[l,h]} \psi_2$: \\
Soundness is simple in this case, since reduce either returns $\res{j}{\phi}$ which is trivially sound, or it returns the semantically correct truth value ($\top/\bot$). Reduce will only return $\top$ if $\exists k \in [j+l,j+h]$ s.t. $\res{k}{\psi_2} = \top$ and $\forall k' \in [j,e]$ $\res{k'}{\psi_1} = \top$ (if any $\psi_1$ residue is $\bot$ then $\bot$ will be returned, and if any are not yet evaluated then unfinished is set and the original residue is returned). This is the semantics of $\mathcal{U}$, so we know that a returned $\top/\bot \rightarrow \sigma, \tau, j \vDash \phi$. Thus reduce is sound for $\mathcal{U}$.

Completeness is trivial because the only possible reduction is a sound $\top/\bot$ value or the original $\phi$. So for all $\res{j}{\psi} \in S^i_{\psi_1 \mathcal{U}_{[l,h]} \psi_2}$ we have $\res{\psi}{j} \equiv \rp{j}{\psi_1 \mathcal{U}_{[l,h]} \psi_2}$ or $\res{\psi}{j} \equiv \top/\bot$. Since reduce is sound, if the residue is $\top/\bot$ we know that the residue value is correct ($\top$ if $\sigma, \tau, j \vDash \phi$ and $\bot$ otherwise) and if a residue $\res{\phi}{j} \equiv \rp{j}{\phi}$ it is trivially complete.

Reduce is prompt $\mathbf{reduce}$


\section{Description}
Our runtime monitoring algorithm \agmon takes as input a well-formed bmtl formula $\varphi$, monitors the system trace as it grows, builds history structures for temporal subformula of $\varphi$ and reports violations of $\varphi$ as soon as they are detected.

We summarize the relevant functions below: \\
$\agmon(\varphi)$ is our top-level monitor function. \\
$\mathbf{incr}(\sigma_i, \tau, i, \hat{\mathcal{R}}^i, \psi)$ updates the history structure $S^i_{\psi}$ based on the new trace entry $\sigma_i$ \\ 
$\mathbf{reduce}(\sigma_i,\tau, i, \mathcal{R}^i, \res{\psi}{j})$ takes a residue $\res{\psi}{j}$ and returns a reduced residue based on the history $\mathcal{R}^i$ and current state $\sigma_i, \tau_i$. 
