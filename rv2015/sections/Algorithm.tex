%%%%% Algorithm section

\section{Monitoring Algorithm}
%% Why our algorithm... 
%%% MTL due to explicit time restrictions
%%% need real-time finite trace checking

In order to monitor our desired ARV system so that it adheres to its specification, 
%distributed embedded systems 
we need an algorithm which %can %continuously 
incrementally checks explicit time specifications (\ie, propositional metric-time temporal logic~\cite{MTL}) over finite system traces. 
This has led to our algorithm \monitor which is an iterative monitoring algorithm based on formula rewriting and summarizing the relevant history of the trace 
in \emph{history-structures}. To detect violations early, \monitor, eagerly checks whether it can reduce subformulas of the original formula to either true/false 
using formula simplifications (\eg, $a\wedge \mathit{false} \equiv \mathit{false}$). Most of the existing algorithms, for evaluating  formulas like $\eventually_{[l,h]} a \vee b$ (read, 
either $b$ is true or sometimes in the future $a$ is true such that the time difference between the evaluation state and the future state in which $a$ is true, $t_d$, is within the bound $[l,h]$) wait 
enough time so that $\eventually_{[l,h]} a$ can be fully evaluated. \monitor however tries to eagerly evaluate both $\eventually_{[l,h]} a$ and $b$ and see whether it can 
reduce the whole formula to either true or false. 
%
%To constantly check that the target system is adhering to its specification, we must constantly check the specification against the current system trace. To constantly check the system efficiently, \monitor is an iterative algorithm, performing additional checking as each new trace step arrives.

\subsection{Specifications}
\monitor checks specifications written in a future-bounded metric temporal logic. Many safety specification rules for safety-critical embedded systems require explicit time bounds to ensure timely behavior, so a specification language with explicit time bounds is important. 
Examples of rules that utilize explicit time bounds include: %
\natlangrule{cruise control shall disengage for 250ms within 500ms of the brake pedal being depressed} ($\pred{brakeDepressed} \rightarrow \eventually_{[0, 500]} \henceforth_{[0,250]} \neg \pred{CruiseEngaged}$), 
\natlangrule{the cruise control mode cannot transition directly from Off to Engaged within 250ms} ($\neg (\pred{CruiseEngaged} \wedge \yesterday_{[0,250]} \pred{CruiseOff})$), 
and \natlangrule{the vehicle should not be within 1m of the current lane edge for 1s while lane centering is enabled} ($\neg \historically_{[0, 1000]}(\pred{LaneCentering} \wedge \pred{distToLaneEdgeLT1m})$).

Our safety specification language for embedded systems, which we call \planguage, is a future bounded, propositional fragment of metric temporal logic (MTL \cite{Koymans1990}) where past temporal operators may have infinite bounds but future temporal operators must have finite bounds. 
The syntax of \planguage is as follows:

\(
\begin{array}{ccc}
\policy & ::=  & \true \mid \pred{p} \mid \neg \policy \mid \policy_1\vee \policy_2\mid
\policy_1\since_{\interval}\policy_2 \mid \policy_1\until_{\interval}\policy_2\mid\yesterday_{\interval}\policy\mid \tomorrow_{\interval}\policy
\end{array}
\) \\
with propositions $\pred{p}$, past temporal operators \emph{since} and \emph{previously} $(\since, \yesterday)$ and future temporal operators \emph{until} and \emph{next} $(\until, \tomorrow)$. The temporal bound $\interval$ must be future-finitely bounded.
Specification propositions come from a finite set of atomic propositions provided in the system trace by the \sfmap. 
These propositions are derived from the observable system state and represent system properties, for example, a proposition $\pred{speedLT40mph}$ could state whether the vehicle speed is less than 40mph.
%
The semantics of \planguage are standard for MTL, \eg, \cite{Basin2008}.

%\paragraph{Semantics. }
%\planguage formulas are interpreted over time-stamped \emph{traces}. A trace $\sigma$ is a sequence of states, each of which maps all propositions in \cP, to either \true or \false. We denote the $i^{th}$ position of the trace with $\sigma_i$ where $i\in\mathbb{N}$. Moreover, each $\sigma_i$ has an associated time stamp denoted by $\tau_i$ where $\tau_i\in\mathbb{N}$. 
%We denote the sequence of time stamps with $\tau$. For all $i, j\in\mathbb{N}$ such that $i < j$, we require $\tau_i < \tau_j$. For a given trace $\sigma$ and time stamp sequence $\tau$, we write $\sigma, \tau, i\models\policy$ to denote that the formula \policy is true with respect to the $i^{th}$ position of $\sigma$ and $\tau$. 

Our monitoring algorithm utilizes \emph{residues}, which are partially reduced (\ie, rewritten) policy formulas representing the remaining portion of a formula which could not be fully evaluated given the current trace. A residue $r^j_{\policy}$ is a tagged pair $\rpt{j}{\policyv}{\policy}$ where $j$ is a position in the trace, $\policy$ is the original residue formula and $\policyv$ is the residual formula. We use these residues to efficiently hold policy history for future time formulas which cannot be evaluated due to incomplete information. 

Policy formulas have a wait delay $\wdelay(\policy)$ which defines an upper bound on the time duration necessary to guarantee complete information to evaluate the formula. Past and present-time formulas have no wait delay, since all trace steps necessary to evaluate them have already been seen by the monitor. Future time formulas have a delay based on their duration (\eg, $\wdelay(\LTLdiamond_{[0,3]} \pred{p}) = 3$). The length $|\policy|$ of a policy $\policy$ is defined as the total number of subformula, (\ie, the number of nodes in the policy AST).

To evaluate \planguage policies, we need to save a limited amount of history state of child policies of temporal subformula within a policy. 
For example, given the policy $\pred{ACCCancelReq} \rightarrow \eventually_{\interval} \pred{ACCOff} \vee (\pred{ACCOn} \since_{\interval} \pred{ACCCancelReq})$, $\pred{ACCOff}$ is a child policy of the temporal formula $\eventually_{\interval} \pred{ACCOff}$ and $\pred{ACCOn}$ and $\pred{ACCCancelReq}$ are children of the temporal formula $\pred{ACCOn} \since_{\interval} \pred{ACCCancelReq}$. 
The monitor must store some history of these child policies in order to evaluate the parent policy.
The operation $\tempSub(\varphi)$ identifies all the children of temporal subformula of a policy $\varphi$.
%% might want to do a more abstract example to show recursiveness
%That is, for $\alpha\, \mathcal{U}_{[l,h]}\, \beta$ we need to save the history of $\alpha$ and $\beta$ (and if either of those are also a temporal formula then we need their history as well). 


%% maybe need formula length, storage delay, simplify\dots


\subsection{Monitoring Algorithm}
Our runtime monitoring algorithm \monitor takes as input a specification $\policy$ and monitors a growing trace, building history structures and reporting the specification violations as soon as they are detected. We summarize the relevant algorithm functions below:

\begin{description}
\item[$\monitor{}(\policy)$] is the top-level function. 
\item[$\reduce(\sigma_i, \tau_i, \histSt{i}, \rpt{i}{\policy}{\policy})$] reduces the given residue based on the current state $(\sigma_i,\tau_i)$ and the history $\histSt{i}$.
\item[$\tempSub(\policy)$] identifies the sub-formulas which require a history structure to evaluate the policy $\policy$.
\item[$\incrS(\histst{i-1}, \histSt{i}, \sigma_i, \tau_i, i)$] updates the history structure $\histst{i-1}$ to step $i$ given the current trace and history state.
\end{description}




\subsubsection{Top-level monitoring algorithm}
The top-level monitoring algorithm \monitor is a sampling-based periodic monitor which uses history structures to store trace state for evaluating temporal subformulas. 
\emph{History structures} are lists of residues along with past-time markers for evaluating infinite past-time formulas. 
The algorithm checks the given policy $\policy$ periodically at every trace sample step. 
When the policy cannot be decided at a given step (\eg, it requires future state to evaluate), the remaining policy residue is saved in a history structure for evaluation in future steps when the state will be available. 
The history structure for formula $\policyv$ at trace step $i$ is denoted $\histst[\policyv]{i}$. 
We use $\histSt[\policy]{i}$ to denote the set of history structures for all temporal subformula of $\policy$, \ie, 
$\histSt[\policy]{i} = \bigcup_{\policyv \in \tempSub(\policy)} \histst[\policyv]{i}$.

The high level algorithm \monitor is shown in Figure \ref{fig:algorithm}. 
%
First, all the necessary history structures $\histst[\policyv]{ }$ are identified using $\tempSub(\policy)$ and initialized. 
Once these structures are identified, the monitoring loop begins.
%
In each step, all the history structures are updated with the new trace step. 
This is done in increasing formula size since larger formula can depend on the history of smaller formula (which may be their subformula).
%
Each structure is updated using $\incrS(\histst[\policyv]{i-1},\histSt[\policyv]{i}, \sigma_i, \tau_i, i)$ which adds a residue for the current trace step to the structure and reduces all the contained residues with the new step state. 
Then, the same procedure is performed for the top level policy that is being monitored -- the policy's structure is updated with $\incrS(\histst{i-1},\histSt{i},\sigma_i,\tau_i, i)$.
Once updated, this structure contains the evaluation of the top-level policy. The algorithm reports any identified policy violations (\ie, any $\false$ residues) before continuing to the next trace step.
%
We note that due to the recursive nature of the monitoring algorithm, the top-level policy is treated exactly the same as any temporal subformula would be (which follows from the fact that the top-level policy contains an implicit \emph{always} $\henceforth$). 
The history structure updates for the top-level policy are separated in the algorithm description for clarity only.
The only difference between the top-level policy and other temporal subformula is that violations are reported for the top-level policy. 

\begin{figure}
\begin{algorithmic}[1]
%\STATE Recognize formulas for which we build structures
\STATE For all recognized formulas $\policyv \in \tempSub(\policy)$: $\histst[\policy_1]{-1} \leftarrow \emptyset$
\STATE $i \leftarrow 0$
\LOOP
\STATE Obtain next trace step $(\sigma_i, \tau_i)$ 
\FOR{every $\policyv \in \tempSub(\policy)$ in increasing size}
	\STATE $\histst[\policyv]{i} \leftarrow \incrS(\histst[\policyv]{i-1}, \histSt[\policyv]{i}, \sigma_i, \tau_i, i)$
\ENDFOR
\STATE $\histst{i} \leftarrow \incrS(\histst{i-1}, \histSt{i}, \sigma_i, \tau_i, i)$
%\FOR{all $\rp{j}{\bot} \in S^i_{\varphi}$}
\FOR{all $\rp{j}{\false} \in \histst{i}$}
\STATE \texttt{Report violation on $\sigma$ at position $j$}
\ENDFOR
\STATE $i \leftarrow i + 1$
\ENDLOOP
\end{algorithmic}
\caption{\monitor Algorithm}\label{fig:algorithm}
\end{figure}

\subsubsection{Reducing Residues}
\monitor works primarily by reducing policy residues down to truth values. Residues are reduced by the $\reduce(\sigma_i, \tau_i, \histSt{i}, \rpt{j}{\policyv}{\policy})$ function, which uses the current state ($\sigma_i,\tau_i$) and the stored history in $\histSt{i}$ to rewrite the policy $\policyv$ to a reduced form, either a truth value or a new policy which will evaluate to the same truth value as the original. For past or present-time formulas, $\reduce()$ is able to return a truth value residue since all the necessary information to decide the policy is available in the history and current state. Future-time policies may be fully-reducable if enough state information is available. If a future-time policy cannot be reduced to a truth value, it is returned as a residue unchanged.

\subsubsection{Incrementing History Structures}
To evaluate past and future-time policies, we must correctly store trace history which can be looked up during a residue reduction. 
We store the trace history of a policy $\policyv$ in a history structure $\histst[\policyv]{}$. 
This history structure contains a list of residues for the number of steps required to evaluate the top-level policy. History structures are incremented by the function 
$\incrS(\histst[\policyv]{i-1}, \histSt[\policyv]{i}, \sigma_i, \tau_i, i) = (\bigcup_{r \in \histst[\policyv]{i-1}} \reduce(\sigma_i, \tau_i, \histst[\policyv]{i}, r)) \cup \reduce(\sigma_i, \tau_i, \histst[\policyv]{i}, \rp{i}{\policyv})$
%
This function takes the previous step's history structure $\histst[\policyv]{i-1}$ and the current state ($\sigma_i,\tau_i$, and the updated smaller history structures $\histSt[policyv]{i}$) and performs two actions:
%\begin{enumerate}
	1) Adds a residue for the current step $i$ to $\histst[policyv]{i-1}$ and
	2) Reduces all residues contained in $\histst[policyv]{i-1}$ with the current state.
%\end{enumerate}
Together, these two actions leave an updated history structure $\histst[policyv]{i}$ which has updated history information for all the required steps.

\subsection{Algorithm Properties}
There are two important correctness properties of our monitoring algorithm which need to be shown. \emph{Correctness} states that the algorithm's results are correct with respect to the syntax. That is, that if \monitor reports a policy violation, the trace really did violate the policy. Related is \emph{promptness}, which requires that the algorithm provide a decision for the given policy at any given time $t$ within a finite bound, $\wdelay(\policy)$. Promptness requires that the algorithm decide satisfaction as soon as it is guaranteed to be possible to decide. 
%
Besides correctness guarantees, our algorithm is also \emph{eager}. An eager algorithm reports satisfaction as soon as the trace is an informative prefix \cite{Kupferman2001} for the policy. Many temporal policies will be decidable before the promptness delay, providing early detection and extra time for recovery actions compared to monitoring algorithms which wait until the promptness delay to ensure they can check the policy. 

The following theorem states that \monitor is correct and prompt. The theorem requires that the history structures $\histSt{i}$ be consistent at $i$ with respect to the trace $\sigma,\tau$. This means that the history structures contain the actual history of the trace up to step $i$. The algorithm provides this consistency itself if run iteratively from step $0$.

\begin{theorem}[Correctness and Promptness of \monitor]
For all $i \in \mathbb{N}$, all formula $\varphi$, all time stamp sequences $\tau$ and all traces $\sigma$ it is the case that (1) if $\rp{j}{\false} \in \histst{i}$ then $\sigma, \tau, j \nvDash \policy$ and if $\rp{j}{\true} \in \histst{i}$ then $\sigma, \tau, j \vDash \policy$ (Correctness) and (2) if $\tau_i - \tau_j \geq \wdelay(\policy)$ then if $\sigma, \tau, j \nvDash \policy$ then $\rp{j}{\false} \in \histst{i}$ and if $\sigma, \tau, j \vDash \policy$ then $\rp{j}{\true} \in \histst{i}$ (Promptness)
.
\end{theorem}
\textit{Proof.} By mutual induction on the policy formula $\policy$ and time step $i$. See \cite{Kane2015} \\

%Theorem \ref{thm:eagerness} states that \monitor is eager. 
%
%\begin{theorem}[Eagerness of \monitor]
%\label{thm:eagerness}
%For all $i \in \mathbb{N}$, all formula $\varphi$, all time stamp sequences $\tau$ and all traces $\sigma$ it is the case that (1) if $\sigma_0,\ldots,\sigma_i$ is an informative prefix then if $\sigma,\tau, i \vDash \policy$ then $\rpt{i}{\true}{\policy} \in \histst{i}$ and if $\sigma, \tau, i \nvDash \policy$ then $\rpt{i}{\false}{\policy} \in \histst{i}$. 
%\end{theorem}
%\textit{Proof.} By mutual induction on the policy formula $\policy$ and time step $i$. See \cite{TechPaper}
%%%%%%%%%%%%%%%%%%%%%%%%%%% REWRITE LINE %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% REWRITE LINE %%%%%%%%%%%%%%%%%%%%%
