%%%% Background Section

\section{Background}
	% the robustness monitor approach in RV2014 is close to invariants
	% if you define your invariants well (and potentially add different levels of failures (e.g., warnings) you'd get to the same place
	% they require a predictive component in the system  -- we just want envelope
	% horizon is delay
	% observation map is semi-formal mapping

\subsubsection{Monitoring Safety-Critical Embedded Systems}
\label{sec:bg:sc_monitor}
Goodloe and Pike present a thorough survey of monitoring distributed real-time systems in \cite{Goodloe2010}. Notably, they present a set of monitor architecture constraints and propose three abstract monitor architectures in the context of monitoring these types of systems.
%
In \cite{Pike2011} Pike et. al update these constraints with the acronym ``FaCTS'': Functionality, Certifiability, Timing, and SWaP (size, weight and power). 
The Functionality constraint demands that a monitor cannot change the system under observation's (SUO's) behavior unless the target has violated the system specification. 
The Timing constraint similarly says that the monitor can not interfere with the non-faulty SUO's timing (e.g., task period/deadlines).
The Certifiability constraint is a softer constraint, arguing that a monitor should not make re-certification of SUO onerous. This is important because certification can be a major portion of design cost for these systems and nominally simple changes/additions to the SUO can require a broad and costly recertification.
Lastly, safety critical systems are often extremely cost sensitive with tight tolerances for additional physical size, weight or required power. Any monitor we wish to add to an existing system must fit within these existing tolerances.

%The three monitor architectures proposed by Goodloe and Pike are the Bus-Monitor Architecture, the single process monitor architecture, and the distributed process monitor architecture. 
One of Goodloe and Pike's proposed distributed real-time system monitor architectures is the bus-monitor architecture.
The bus monitor architecture has the monitor recieve network messages over an existing system bus just like any other system component. 
The monitor can be configured in a silent or receive only mode to ensure it does not peturb the system. 
This is a simple architecture which requires few (essentially no) changes to the target system architecture. We utilize this architecture for our monitoring framework. The other proposed architectures require either additional buses or distributed monitors, both which add complexity and costs we wish to avoid when integrating a monitor. %for bolt-on monitoring.

%%%% NEED TO SHRINK THIS DOWN TO A PAGE OR TWO
%%%% 	focus on the actual similar algorithms (Thati/Rosu, Havelund, etc)
\subsection{Monitors}
There are many existing runtime monitoring frameworks and monitoring algorithms with different primary uses. Monitoring frameworks provide not just the specification language and checking algorithm, but also the connection between the monitor and target system.
Watterson and Heffernan give an overview of runtime verification tools in \cite{Watterson2007}. 

%%%%
%%%% ALGORITHMS
%PathExplorer \cite{Havelund2002} is a NASA designed architecture for monitoring systems. The target system is instrumented to emit events to the monitor which checks past time LTL formulas using a dynamic programming algorithm. 
The NASA PathExplorer project has led to both a set of dynamic programming-based monitoring algorithms as well as some formula-rewriting based algorithms \cite{Havelund2004} for past-time LTL. These dynamic programming algorithms require checking the trace in reverse (from the end to the beginning) which makes them somewhat unsuitable for online monitoring \cite{Havelund2002}. The formula rewriting algorithms utilize the Maude term rewriting engine to efficiently monitor specifications through formula rewriting \cite{Rosu2005}. 

%There are many dynamic programming algorithms for runtime monitoring. The NASA PathExplorer monitor \cite{Havelund2002} uses on of these, based on 
% Thati2005
Thati and Ro\c{s}u \cite{Thati2005} describe an dynamic programming algorithm for monitoring MTL which is based on resolving the past and deriving the future. They perform formula rewriting which resolves past-time formulas into equivalent formulas without unguarded past-time operators and derive new future-time formulas which separate the current state from future state. 
They store formulas in a canonical form which allows expanding formulas to not grow larger than exponential in the size of the original formula and allows for updating formulas in exponential time. Like many similar algorithms, they store and calculate the necessary histories recursively to evaluate formulas. While they have a tight encoding of their canonical formulas, their monitoring algorithm still requires more state to be stored than some other algorithms (because formulas grow in size as they are rewritten), including the one presented in this thesis. 
%
% compare us to all the havelund/rosu work
Our monitoring algorithm is also based on formula-rewriting, although we use formula reduction only rather than a full set of rewriting rules. Our algorithm can also be thought of as a dynamic programming algorithm, building up history state from the smallest subformula up to the specification policy. 


% Basin2012
Basin et. al. describe a set of MTL monitoring algorithms, specifically focusing on how the time domain affects monitoring \cite{Basin2012}. They point out that while point-based semantics seem fitting for real-time systems which are often viewed as a set of events, the point-based semantics can be unintuitive compared to interval semantics. Our monitoring algorithm works in a very similar way to their point-based monitoring algorithm. They use an iterative recursive algorithm which calculates truth values over the target formula structures utilizing history structures. 
% compare to this basin work
Our $\mathbf{reduce}$ procedure works similarly to their $\mathbf{step}$ procedure, except they only check past-time MTL so $\mathbf{step}$ is always guaranteed to return an answer whereas our $\mathbf{reduce}$ must handle inconclusive formulas as well.

%% partial information
There are some monitoring algorithms designed to handle incomplete trace information. Bauer et. al. present a policy logic for monitoring transaction logs with partial observability (i.e., not all parameters are observable) \cite{Bauer2009}. Basin et. al. also present a monitoring algorithm for incomplete logs due to logging failures or disagreeing logs in \cite{Basin2013}. Other algorithms also handle log incompleteness \cite{Garg2011,Chowdhury2014}.
% compare
Our monitoring framework does not deal with incomplete logs, except for missing future-time trace entries which we expect to eventually obtain. We require that the entire state is available for all observed log steps.

%%%%% 
%%%%% FRAMEWORKS
% discuss existing frameworks and what we borrow


%Copilot
Copilot is a Haskell-based embedded domain specific language for generating runtime monitors for real-time distributed systems \cite{Pike2010}. 
Copilot specifications can be used to generate constant-time and constant-space C code which include their own scheduler and can be run alongside the program to be monitored.
Unlike many of the other discussed monitors, Copilot is designed with distributed safety-critical embedded systems and their constraints in mind. 
Still, Copilot requires code source code access to instrument the target system (and is designed to run on-chip). This is not usable for black-box systems and common-mode faults between the monitor and target system may also be an issue.

%MAC
The Monitoring and Checking (MaC) framework \cite{Lee1999} is a generalized monitoring architecture which instruments the target program to send the targeted state to the monitor. MaC uses a two part specification which separates the implementation specific details from the requirements specification. 
The primitive event definition language (PEDL) is used to specify the low level specification which defines the instrumentation and how the system state is transformed into monitor events. The meta event definition language (MEDL) defines the actual safety rules that get checked. Kim et. al. describe a Java implementation Java-MaC in \cite{Kim2004}.
Our semi-formal interface is similar to MaC's filters which are used to map the system to the checker's formal model. However, MaC's filters are implemented on the instrumented target system (which requires source instrumentation) whereas our mapping is performed on the monitor.

%MOP
Monitor Oriented Programming (MOP) is a generalized framework for incorporating monitors into programs.
BusMOP \cite{Pellizzoni2008} is an external hardware runtime monitor designed to be used in verifying COTS components for real-time embedded systems. BusMOP is one of the few existing monitors which targets systems with COTS components (and thus cannot use any instrumentation). The monitor is an automatically generated FPGA monitor that can sniff a system's network (they use the PCI-E bus) to verify system properties.
This is an external bus monitor architecture similar to our monitoring framework.
%which is an external bus monitoring architecture just like our monitor. 
BusMOP only supports past-time LTL and extended regular expressions so it cannot perform aggressive checking of future-based properties. BusMOP system mappings are defined directly in VHDL (which is compiled into the monitor) while the safety properties are written in a formal logic. Instead of having each monitor be generated based on its mapping, our monitoring algorithm is software based, so the mapping can be written in system level code (or, eventually in a simple domain specific language).

%reinbacher2013
Reinbacher et. al. present an embedded past-time MTL monitor in \cite{Reinbacher2013}. They use a non-invasive FPGA monitor which is generated from the monitor specification. Their architecture is similar to ours, wiretapping the target system interface and passing it through an evaluation unit which creates atomic propositions out of the system state (similar to our semi-formal interface). The actual implementation they describe does however presume system memory access to obtain system state (rather than using state from the target network). The generated atomic propositions are fed into the runtime verification unit which checks the desired ptMTL properties. This monitor is limited to past-time MTL which means it cannot check fully aggressive future properties unlike our monitor which allows both past and future bounded MTL.

%Heffernan2014
Heffernan et. al. present a monitor for automotive systems using ISO 26262 as a guide to identify the monitored properties in \cite{Heffernan2014}. They monitor past-time LTL formulas (using explicit time bounds when necessary) obtaining system state from target system buses (CAN in their example). They use ``filters'' as a system interface, allowing them to generate atomic propositions which get fed to the ``event recognizer'' (i.e., the monitor portion). Our semi-formal interface is equivalent to these filters. 
Their monitor is an on-chip SoC monitor based on previous work which used an informal hardware logic instead of past-time LTL \cite{Heffernan2009}.
%
The motivation and goals behind that work are very similar to ours, but they use on-chip SoC monitors with instrumentation to obtain internal system state. This is an important distinction since on-chip monitors aren't suitable for black-box systems. There is also the risk of common mode failures when the monitor is resident on the same chip as the target system which we try to avoid.

%%%%% OUR Stuff -- anupam/Omar
Our monitoring algorithm is inspired by the algorithms \greduce\ \cite{Garg2011} and \precis\ \cite{Chowdhury2014}, adjusted for our aggressive monitoring and propositional logic use case. 
%
% discuss existing monitors and what we borrow
The algorithm \greduce\ is an offline, iterative monitoring algorithm for auditing privacy and security properties (e.g., HIPAA \cite{HIPAA2002} or GLBA \cite{GLBA1999} requirements) over incomplete logs. It checks a first order logic with restricted quantifiers \cite{Garg2011} using an iterative, formula rewriting-based algorithm.
% omar-based add/edits
Their audit log is a partial structure which maps every ground predicate to either true, false, or unknown.
They require the entire audit log to be stored and available for monitoring instead of summarizing the history in a structure.
Storing the entire system log (i.e., the trace) is not a feasible approach for an embedded monitor because the traces continuously grow and thus can become very large.
%
They also use explicit (quantified) time values rather than temporal logic to handle time-based constraints. 

The structure of our monitoring algorithm is based on Garg's \greduce\ algorithm. 
We also use an iterative, formula-rewriting based algorithm (with the primary procedure also named $\mathbf{reduce}$), although our algorithm can be used for both online or offline monitoring. 
Our algorithm works in a similar way, recursively reducing subformula and returning residual formulas for ``incomplete'' or unreducable traces. We target a bounded propositional metric temporal logic, so we do not need to deal with substitution of quantified variables. We only need propositional logic because embedded systems are typically fully specified at design time (i.e., we know all the possible network nodes and messages).
%
Both algorithms can return residual (i.e., incompletely reduced) formulas, but the reasons for incompleteness of these two algorithms are different. Garg et. al.'s \greduce\ can return residual formulas due to unknown predicate substitutions or incomplete logs. Our $\mathbf{reduce}$ returns residual formulas when the truth value of a temporal formula is currently inconclusive (i.e., depends on future values).
%
Our algorithm only handles incompleteness caused by needing to see future state. We do not consider incomplete traces due to missing information. 
We use a bounded propositional metric temporal logic rather than a first order logic, so we do not need structures to aid in substitution of quanitified variables. 
We do use structures to store any relevant state history to avoid storing the entire trace.
%We do use structures to contain state history in a similar way. 

The online, iterative monitoring algorithm \precis\ generalizes Garg et. al's \greduce. 
The \precis\ algorithm tries to summarize the log history as structures and falls back on \greduce\ style brute force checking when a summary structure cannot be built.
Many existing monitoring algorithms are special cases of \precis.
When it is possible for \precis\ to build structures for all subformulas it performs a typical runtime monitoring algorithm (i.e., checking the stored structure state following the semantics) whereas when it is not possible to build any structures \precis\ works similarly to \greduce.

\precis\ performs online, iterative checking of metric first order temporal logic properties. 
Our overall algorithm \agmon\ is based on \precis, with a similarly structured algorithm -- updating all history structures then checking the desired formulas. Our algorithm \agmon\ performs aggressive checking of future-time formulas (attempting to reduce them as soon as possible) while \precis\ delays the checking of future-time formulas until they are guaranteed to be reducable. We do use this delaying tactic in our conservative checking algorithm.
We use a simpler propositional logic instead of \precis{}'s metric first-order temporal logic. Instead of storing summary structures for predicate substitutions we keep subformula history structures.


\subsection{Controller Area Network}
Controller Area Network (CAN) is a widely used automotive network developed by Bosch in the 1980s. 
In this work we focus primarily on monitoring CAN because it is a common automotive bus which typically conveys a lot of the state we wish to observe without instrumentation.
%
CAN is an event-based broadcast network with data rates up to 1Mb/s (although usually used at 125-500kbps). Messages on CAN are broadcast with an identifier which is used to denote both the message and the intended recipients. The message identifiers are also used as the message priorities for access control.

Although CAN is an event-based bus it is often used in a somewhat periodic, time triggered way so the network usage can be statically analyzed. Because of this our monitoring scheme is based on a time-triggered network sampling model, so it can monitor time-triggered networks as well.

%%%%%%%%%%%%%%
