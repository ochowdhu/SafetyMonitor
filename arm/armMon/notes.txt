Just keeping some notes here

Started working on smaller simplification tables to handle bigger scaling --
retag seems reasonable, just need to finish implementing and test it

WRITEUP STUFF:
	monitor initialization can be tricky -- how to handle past time that looks
	before trace?
		right now the temporal operator returns true -- still check the rest
		of the formula. Could do throwaway or spin-up instead.
		This means that formula must be built to survive startup (no
		"~[[0,10]] X" without a guard, it will fail at steps 0-10
			rewrite as <<0,10>> ~X or do future time to get around
	
TODO: 
	TEST!!
	run experiments
	-- need to get GM data running on pc-version
	start doing simulator timing analysis

artificial trace data ---
	We have 3 "dimensions"
		conservative/aggressive
			tradeoff # computations for "speed to eval"
		interval/lists
			tradeoff space and worst case execution for common/best case execution
		restricted/full logic
			tradeoff space for execution speed (formula dependent)
			approx 2k code size

important properties for an algorithm:
	total execution time per step
		# reduce calls per step
	steps to reduce/time to reduce
		avg?
		min?
		max?


table:
					total exec		steps2red	avg		min		max
increasing duration
cons					static		static		dur		dur*	dur
aggr					incr		dyn			<dur	1		dur

Show properties:
	conservative -- steady total execution, steady time to reduce
	aggressive -- time to exec increases as duration increases, time to reduce trace/formula dependent

single temporal with increasing duration
	cons -- exec steady, time to reduce == delay
	aggr -- exec time increases, time to reduce depends on formula, better than cons


Traces we need to run:
	single temporal with increasing duration

	nesting with increasing depth (across durations?)

	Full vs restricted logic
		same formula -- should have same results
		formulas that are better for full
			across durations!
		any that are worse for full?
			can always write in restricted...

	aggressive vs conservative
		overall computation
		time to eval
		best vs worst case



